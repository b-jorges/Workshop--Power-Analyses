Time_Ongoing < 40), aes(Time_Ongoing, y_object)) +
geom_point() +
geom_point(aes(Time_Ongoing, y_response), color = "red")
ggplot(Responses_Wide %>% filter(Time_Ongoing > 40 &
Time_Ongoing < 45), aes(Time_Ongoing, y_object)) +
geom_point() +
geom_point(aes(Time_Ongoing, y_response), color = "red")
ggplot(Responses_Wide %>% filter(Time_Ongoing > 45 &
Time_Ongoing < 50), aes(Time_Ongoing, y_object)) +
geom_point() +
geom_point(aes(Time_Ongoing, y_response), color = "red")
ggplot(Responses_Wide %>% filter(Time_Ongoing > 45 &
Time_Ongoing < 50), aes(Time_Ongoing, x_object)) +
geom_point() +
geom_point(aes(Time_Ongoing, x_response), color = "red")
ggplot(Responses_Wide %>% filter(Time_Ongoing > 45 &
Time_Ongoing < 50), aes(Time_Ongoing, y_object)) +
geom_point() +
geom_point(aes(Time_Ongoing, y_response), color = "red")
#x-z distance between observer and drone
Responses_Wide = Responses_Wide %>%
mutate(z_Pos_Plane = 15,
x_Opposite = tan(DegreeToRadians(yalpha_controller))*(z_Pos_Plane - z_controller),
y_Opposite = -tan(DegreeToRadians(xalpha_controller))*(z_Pos_Plane - z_controller),
x_response = x_Opposite + x_controller,
y_response = y_Opposite + y_controller - 1.3,
delta_x_object = x_object - lag(x_object, 1),
delta_y_object = y_object - lag(y_object, 1),
delta_x_response = x_response - lag(x_response, 1),
delta_y_response = y_response - lag(y_response, 1),
Angle_Object = case_when(
delta_x_object > 0 & delta_y_object > 0 ~ RadiansToDegree(atan(abs(delta_y_object)/abs(delta_x_object))),
delta_x_object < 0 & delta_y_object > 0 ~ 90 + RadiansToDegree(atan(abs(delta_x_object)/abs(delta_y_object))),
delta_x_object < 0 & delta_y_object < 0 ~ 180 + RadiansToDegree(atan(abs(delta_y_object)/abs(delta_x_object))),
delta_x_object > 0 & delta_y_object < 0 ~ 270 + RadiansToDegree(atan(abs(delta_x_object)/abs(delta_y_object)))),
Angle_Response = case_when(
delta_x_response > 0 & delta_y_response > 0 ~ RadiansToDegree(atan(abs(delta_y_response)/abs(delta_x_response))),
delta_x_response < 0 & delta_y_response > 0 ~ 90 + RadiansToDegree(atan(abs(delta_x_response)/abs(delta_y_response))),
delta_x_response < 0 & delta_y_response < 0 ~ 180 + RadiansToDegree(atan(abs(delta_y_response)/abs(delta_x_response))),
delta_x_response > 0 & delta_y_response < 0 ~ 270 + RadiansToDegree(atan(abs(delta_x_response)/abs(delta_y_response)))))
ggplot(Responses_Wide %>% filter(Time_Ongoing > 45 &
Time_Ongoing < 50), aes(Time_Ongoing, y_object)) +
geom_point() +
geom_point(aes(Time_Ongoing, y_response), color = "red")
#x-z distance between observer and drone
Responses_Wide = Responses_Wide %>%
mutate(z_Pos_Plane = 15,
x_Opposite = tan(DegreeToRadians(yalpha_controller))*(z_Pos_Plane - z_controller),
y_Opposite = -tan(DegreeToRadians(xalpha_controller))*(z_Pos_Plane - z_controller),
x_response = x_Opposite + x_controller,
y_response = y_Opposite + y_controller,
delta_x_object = x_object - lag(x_object, 1),
delta_y_object = y_object - lag(y_object, 1),
delta_x_response = x_response - lag(x_response, 1),
delta_y_response = y_response - lag(y_response, 1),
Angle_Object = case_when(
delta_x_object > 0 & delta_y_object > 0 ~ RadiansToDegree(atan(abs(delta_y_object)/abs(delta_x_object))),
delta_x_object < 0 & delta_y_object > 0 ~ 90 + RadiansToDegree(atan(abs(delta_x_object)/abs(delta_y_object))),
delta_x_object < 0 & delta_y_object < 0 ~ 180 + RadiansToDegree(atan(abs(delta_y_object)/abs(delta_x_object))),
delta_x_object > 0 & delta_y_object < 0 ~ 270 + RadiansToDegree(atan(abs(delta_x_object)/abs(delta_y_object)))),
Angle_Response = case_when(
delta_x_response > 0 & delta_y_response > 0 ~ RadiansToDegree(atan(abs(delta_y_response)/abs(delta_x_response))),
delta_x_response < 0 & delta_y_response > 0 ~ 90 + RadiansToDegree(atan(abs(delta_x_response)/abs(delta_y_response))),
delta_x_response < 0 & delta_y_response < 0 ~ 180 + RadiansToDegree(atan(abs(delta_y_response)/abs(delta_x_response))),
delta_x_response > 0 & delta_y_response < 0 ~ 270 + RadiansToDegree(atan(abs(delta_x_response)/abs(delta_y_response)))))
ggplot(Responses_Wide %>% filter(Time_Ongoing > 30 & Time_Ongoing < 50), aes(Time_Ongoing, Angle_Object)) +
geom_point() +
geom_point(aes(Time_Ongoing, Angle_Response), color = "red")
ggplot(Responses_Wide %>% filter(Time_Ongoing > 45 &
Time_Ongoing < 50), aes(Time_Ongoing, y_object)) +
geom_point() +
geom_point(aes(Time_Ongoing, y_response), color = "red")
ggplot(Responses_Wide %>% filter(Time_Ongoing > 30 & Time_Ongoing < 50), aes(Time_Ongoing, Angle_Object)) +
geom_point() +
geom_point(aes(Time_Ongoing, Angle_Response), color = "red")
ggplot(Responses_Wide %>% filter(Time_Ongoing > 30 &
Time_Ongoing < 50 &
LineCounter == 89), aes(Time_Ongoing, x_object)) +
geom_point() +
geom_point(aes(Time_Ongoing, x_response), color = "red")
ggplot(Responses_Wide %>% filter(Time_Ongoing > 30 &
Time_Ongoing < 50 &
LineCounter == 89), aes(Time_Ongoing, y_object)) +
geom_point() +
geom_point(aes(Time_Ongoing, y_response), color = "red")
Responses_Wide = Responses_Wide %>%
mutate(LineCounter_MinusOne = LineCounter-1)
require(dplyr)
require(ggplot2)
require(cowplot)
theme_set(theme_cowplot())
MaxDistance = 0.22
set.seed(65)
DegreeToRadians <- function(degree){
radians <- degree*0.01745
radians
}
RadiansToDegree <- function(radians){
degree <- radians/0.01745
degree
}
for (m in seq(0,9,1)){
NumberOfSeconds = 120*1
TimeAcross = 1
####First get to edge
Angle = runif(1,0,360)
#find where it hits the 22cm circle:
#cos(Angle) = x/0.22
New_Pos_x = cos(DegreeToRadians(Angle))*0.22
#sin(Angle) = z/0.22
New_Pos_z = sin(DegreeToRadians(Angle))*0.22
Distance = (New_Pos_x^2 + New_Pos_z^2)^0.5
Pos_x = c(New_Pos_x)
Pos_z = c(New_Pos_z)
Distances = c(Distance)
Times = c(TimeAcross)
Angles = c(90 + Angle)
Delta_x = c(0)
Delta_z = c(0)
Time = 1.5
for (i in seq(1,120,1)){
####Now bounce around
#choose angle to add to "inverse" of previous angle
Angle = rnorm(1,Angle + 180,40)
if (Angle > 360){
Angle = Angle -360
}
#Get Distance to circle!
Time = Time + TimeAcross
Old_Pos_x = New_Pos_x
Old_Pos_z = New_Pos_z
New_Pos_x = cos(DegreeToRadians(Angle))*0.22
#sin(Angle) = z/0.22
New_Pos_z = sin(DegreeToRadians(Angle))*0.22
Distance = ((New_Pos_x-Old_Pos_x)^2 + (New_Pos_z-Old_Pos_z)^2)^0.5
Pos_x = c(Pos_x, New_Pos_x)
Pos_z = c(Pos_z, New_Pos_z)
Delta_x = c(Delta_x, New_Pos_x-Old_Pos_x)
Delta_z = c(Delta_z, New_Pos_z-Old_Pos_z)
#tan(alpha) = opposite/adjacent
#alpha = atan(opposite/adjacent)
# HeadingDirection = if (New_Pos_x-Old_Pos_x > 0 & New_Pos_z-Old_Pos_z > 0){
#     RadiansToDegree(atan((New_Pos_x-Old_Pos_x)/(New_Pos_z-Old_Pos_z)))
#   } else if (New_Pos_x-Old_Pos_x > 0 & New_Pos_z-Old_Pos_z < 0){
#     270 + RadiansToDegree(acos((New_Pos_x-Old_Pos_x)/(New_Pos_z-Old_Pos_z)))
#   } else if (New_Pos_x-Old_Pos_x < 0 & New_Pos_z-Old_Pos_z > 0){
#     180 + RadiansToDegree(asin((New_Pos_x-Old_Pos_x)/(New_Pos_z-Old_Pos_z)))
#   } else if (New_Pos_x-Old_Pos_x < 0 & New_Pos_z-Old_Pos_z < 0){
#     180 + RadiansToDegree(acos((New_Pos_x-Old_Pos_x)/(New_Pos_z-Old_Pos_z)))}
HeadingDirection = if ((New_Pos_x-Old_Pos_x) > 0 & (New_Pos_z-Old_Pos_z) > 0){
90 + RadiansToDegree(atan((New_Pos_z-Old_Pos_z)/(New_Pos_x-Old_Pos_x)))
} else if ((New_Pos_x-Old_Pos_x) > 0 & (New_Pos_z-Old_Pos_z) < 0){
abs(RadiansToDegree(atan((New_Pos_x-Old_Pos_x)/(New_Pos_z-Old_Pos_z))))
} else if ((New_Pos_x-Old_Pos_x) < 0 & (New_Pos_z-Old_Pos_z) > 0){
180 + abs(RadiansToDegree(atan((New_Pos_x-Old_Pos_x)/(New_Pos_z-Old_Pos_z))))
} else if ((New_Pos_x-Old_Pos_x) < 0 & (New_Pos_z-Old_Pos_z) < 0){
270 + RadiansToDegree(atan((New_Pos_z-Old_Pos_z)/(New_Pos_x-Old_Pos_x)))}
Angles = c(Angles, HeadingDirection)
Distances = c(Distances, Distance)
Times = c(Times, Time)
}
Dataframe = data.frame(Pos_x, Pos_z, Delta_x, Delta_z, Times, Angles, VisionAngle = 0, Distances)
write.table(Dataframe %>% select(Pos_x,Pos_z,Times, Angles, VisionAngle, Distances),
paste0(dirname(rstudioapi::getSourceEditorContext()$path),"/Pre-Generated Paths v2/MOOG_Positions_",m,".txt"),
row.names = FALSE, col.names = FALSE)
}
OnePath = read.table(paste0(dirname(rstudioapi::getSourceEditorContext()$path),"/Pre-Generated Paths v2/MOOG_Positions_0",".txt"))
colnames(OnePath) = c("x", "y", "Time", "Angles", "VisionAngle", "Distance")
Figure2_A = ggplot(OnePath, aes(x, y, color = Time)) +
geom_path(linewidth = 2) +
xlab("x position (m)") +
ylab("y position (m)") +
scale_color_continuous(name = "Time (s)")
Figure2_B = ggplot(OnePath, aes(Time,Angles, color = Time)) +
geom_point() +
geom_line() +
xlab("Time (s)") +
ylab("Heading (°)") +
scale_color_continuous(name = "Time (s)") +
scale_y_continuous(breaks = c(0,90, 180, 270, 360))
Figure2_D = ggplot(OnePath,
aes(Angles)) +
geom_density() +
xlab("Angle (°)") +
ylab("Density") +
scale_x_continuous(breaks = c(0, 90,180,270, 360))
#Look at speeds/accelerations
OnePath_Frames = c()
for (i in 1:90){
OnePath_Frames = rbind(OnePath_Frames,OnePath)
}
OnePath_Frames = OnePath_Frames %>%
arrange(Time) %>%
group_by(Time) %>%
mutate(Time_Continuous = Time + seq(0,1.5-1/90,1/60),
Multiplier_Raw = pnorm(Time_Continuous %% 1.5,0.75,0.2) - lag(pnorm(Time_Continuous %% 1.5,0.75,0.2)),
Multiplier = Multiplier_Raw/mean(Multiplier_Raw, na.rm = TRUE),
Speed = Multiplier * (Distance/1.5),
Acceleration = (Speed-lag(Speed,1))/(1/60))
1/mean(OnePath_Frames$Multiplier_Raw, na.rm = TRUE) #this number goes into row #7 of the .txt (: except its not really this number for some reason! Check iiit ... it's like 80 instead? But the MOOG cant handle 80 :(
ggplot(OnePath_Frames %>% filter(Time_Continuous > 3 & Time_Continuous < 6), aes(Time_Continuous,Speed)) +
geom_point() +
ylab("Speed (m/s)") +
xlab("Time (s)")
ggplot(OnePath_Frames %>% filter(Time_Continuous > 3 & Time_Continuous < 6), aes(Time_Continuous,Acceleration)) +
geom_point() +
ylab("Acceleration (m^2/s)") +
xlab("Time (s)")
ggplot(OnePath_Frames %>% filter(Time_Continuous > 3 & Time_Continuous < 6), aes(Time_Continuous,Multiplier)) +
geom_point() +
xlab("Time (s)")
mean(OnePath_Frames$Multiplier_Raw, na.rm = TRUE)
ggplot(OnePath_Frames %>% filter(Time_Continuous > 3 & Time_Continuous < 6), aes(Time_Continuous,Multiplier_Raw)) +
geom_point() +
ylab("Acceleration (m^2/s)") +
xlab("Time (s)")
Time_Continuous = seq(0,1-1/60,1/60)
plot(Time_Continuous, pnorm(Time_Continuous, 0.5,0.15) - lag(pnorm(Time_Continuous, 0.5,0.15),1))
Responses_Wide$ID
Responses_Wide$Trajectory_Number
Responses_Wide$LineCounter
require(dplyr)
require(ggplot2)
require(cowplot)
require(ggdist)
theme_set(theme_cowplot())
flist <- list.files(paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/Data"))[c(grep("PM.txt", list.files(paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/Data"), full.names = TRUE)),
grep("AM.txt", list.files(paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/Data"), full.names = TRUE)))]
Responses_Wide = c()
Data2 = c()
j = 0
for (i in flist){
j = j+1
print(j)
if (j == 1){
Responses_Wide  = read.table(paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/Data/",i), header = TRUE, row.names = NULL)
} else {
Data2  = read.table(paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/Data/",i), header = TRUE, row.names = NULL)
}
Responses_Wide = rbind(Responses_Wide,Data2)
}
RadiansToDegree <- function(radians){
degree <- radians/0.01745
degree
}
DegreeToRadians <- function(Degree){
Radians <- Degree*0.01745
Radians
}
#x-z distance between observer and drone
Responses_Wide = Responses_Wide %>%
mutate(z_Pos_Plane = 15,
x_Opposite = tan(DegreeToRadians(yalpha_controller))*(z_Pos_Plane - z_controller),
y_Opposite = -tan(DegreeToRadians(xalpha_controller))*(z_Pos_Plane - z_controller),
x_response = x_Opposite + x_controller,
y_response = y_Opposite + y_controller,
delta_x_object = x_object - lag(x_object, 1),
delta_y_object = y_object - lag(y_object, 1),
delta_x_response = x_response - lag(x_response, 1),
delta_y_response = y_response - lag(y_response, 1),
Angle_Object = case_when(
delta_x_object > 0 & delta_y_object > 0 ~ RadiansToDegree(atan(abs(delta_y_object)/abs(delta_x_object))),
delta_x_object < 0 & delta_y_object > 0 ~ 90 + RadiansToDegree(atan(abs(delta_x_object)/abs(delta_y_object))),
delta_x_object < 0 & delta_y_object < 0 ~ 180 + RadiansToDegree(atan(abs(delta_y_object)/abs(delta_x_object))),
delta_x_object > 0 & delta_y_object < 0 ~ 270 + RadiansToDegree(atan(abs(delta_x_object)/abs(delta_y_object)))),
Angle_Response = case_when(
delta_x_response > 0 & delta_y_response > 0 ~ RadiansToDegree(atan(abs(delta_y_response)/abs(delta_x_response))),
delta_x_response < 0 & delta_y_response > 0 ~ 90 + RadiansToDegree(atan(abs(delta_x_response)/abs(delta_y_response))),
delta_x_response < 0 & delta_y_response < 0 ~ 180 + RadiansToDegree(atan(abs(delta_y_response)/abs(delta_x_response))),
delta_x_response > 0 & delta_y_response < 0 ~ 270 + RadiansToDegree(atan(abs(delta_x_response)/abs(delta_y_response)))))
require(dplyr)
require(ggplot2)
require(purrr)
require(lme4)
require(lmerTest)
setwd(paste0(dirname(rstudioapi::getSourceEditorContext()$path)))
source(paste0(dirname(rstudioapi::getSourceEditorContext()$path),"/GetValuesFromPilotData.R"))
############Make a function to simulate the data
#This function simulates one full data depending on a whole bunch of parameters. (Perception is complicated!)
SimulatePsychometricData = function(nParticipants, #how many participants?
ConditionOfInterest1, #name for the first Condition of Interest
ConditionOfInterest2, #name for the second Condition of Interest
StandardValues, #vector with the values for the standard value (i.e., speed of the single sphere in the example)
reps, #how many repetitions per condition? Can range between 30-40-50 for very short staircases, up to several 100s, especially for method of constant stimuli
PSE_Difference_CoI1, #PSE difference between the two levels of CoI 1
PSE_Difference_CoI2, #PSE difference between the two levels of CoI 2
PSE_Interaction, #PSE interaction between CoI 1 and CoI 2
JND_Difference_CoI1, #JND difference between the two levels of CoI 1
JND_Difference_CoI2, #JND difference between the two levels of CoI 2
JND_Interaction, #JND interaction between CoI 1 and CoI 2
Multiplicator_PSE_Standard, #At how many percent of the veridical stimulus strength do we perceive it baseline? (e.g., discrepancies introduced by single sphere versus sphere cloud)
Multiplicator_SD_Standard, #What's the JND at baseline in % of stimulus strength?
Type_ResponseFunction, #which function do we use to simulate the presented stimulus strengths?
#normal or Cauchy for staircases
SD_ResponseFunction,#how wide should this function be? standard deviation if normal distribution, scale for Cauchy
Mean_Variability_Between,#between participant variability in baseline performance in PSE
SD_Variability_Between){#between participant variability in baseline performance in JND
#make a vector with an ID for each simulated participant
ID = paste0("p0",1:nParticipants)
#make a dataframe from the given values to work with, with one row per trial per participant and condition
Psychometric = expand.grid(ID=ID,
ConditionOfInterest1=ConditionOfInterest1,
ConditionOfInterest2=ConditionOfInterest2,
StandardValues=StandardValues,
reps = 1:reps)
#Factor in between-participant variability for PSE/JND
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,Mean_Variability_Between), #how much variability is in the means of the psychometric functions between subjects?
SD_Factor_ID = rnorm(1,1,SD_Variability_Between)) #how much variability is in the standard deviations of the psychometric functions between subjects?
Psychometric = Psychometric %>%
ungroup() %>%
mutate(
#factor in "Multiplicator_PSE_Standard", i.e., if there is any difference between presented stimulus strength and baseline PSEs
Mean_Standard = StandardValues*Multiplicator_PSE_Standard,
#same but for the JND. What's the expected average JND as % of the standard value?
SD_Standard = StandardValues*Multiplicator_SD_Standard,
#Factor in expected effects for CoI1, CoI2 and their interaction (PSE)
Mean_Step1 = case_when(
ConditionOfInterest1 == "1Environment" & ConditionOfInterest2 == "1Fixation" ~ Mean_Standard,
ConditionOfInterest1 == "1Environment" & ConditionOfInterest2 == "2Pursuit" ~ Mean_Standard + Mean_Standard*PSE_Difference_CoI2,
ConditionOfInterest1 == "2No_Environment" & ConditionOfInterest2 == "1Fixation" ~ Mean_Standard + Mean_Standard*PSE_Difference_CoI1,
ConditionOfInterest1 == "2No_Environment" & ConditionOfInterest2 == "2Pursuit" ~ Mean_Standard + Mean_Standard*PSE_Difference_CoI1 +
Mean_Standard*PSE_Difference_CoI2 +
Mean_Standard*PSE_Interaction),
#Factor in expected effects for CoI1, CoI2 and their interaction (JND)
SD_Step1 = case_when(
ConditionOfInterest1 == "1Environment" & ConditionOfInterest2 == "1Fixation" ~ SD_Standard,
ConditionOfInterest1 == "1Environment" & ConditionOfInterest2 == "2Pursuit" ~ SD_Standard + JND_Difference_CoI2,
ConditionOfInterest1 == "2No_Environment" & ConditionOfInterest2 == "1Fixation" ~ SD_Standard + JND_Difference_CoI1,
ConditionOfInterest1 == "2No_Environment" & ConditionOfInterest2 == "2Pursuit" ~ SD_Standard + JND_Difference_CoI1 +
JND_Difference_CoI2 +
JND_Interaction))
#factor in between-participant variability (PSE_Factor_ID and SD_Factor_ID) into the average PSEs/JNDs per condition
Psychometric = Psychometric %>%
mutate(
Mean = Mean_Step1*PSE_Factor_ID,
SD = SD_Step1*SD_Factor_ID)
#Which function to we pick values from? normal or Cauchy?
if (Type_ResponseFunction == "normal"){
Psychometric = Psychometric %>%
mutate(
staircase_factor = rnorm(length(reps),1,SD_ResponseFunction))
} else if (Type_ResponseFunction == "Cauchy"){
Psychometric = Psychometric %>%
mutate(
staircase_factor = rcauchy(length(reps),1,SD_ResponseFunction))
} else{
print("distribution not valid")
}
#Scale the presented stimulus strength to the actual values
Psychometric = Psychometric %>%
mutate(Presented_TestStimulusStrength = Mean*staircase_factor)
Psychometric = Psychometric %>%
mutate(
#Calculate the probability to choose "standard stimulus is more intense"
AnswerProbability = pnorm(Presented_TestStimulusStrength,Mean,abs(SD)),
#draw binary yes/no responses based on these probabilities
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
Psychometric
}
###############################################################
###########################simulate one data set###############
###############################################################
#set the parameters
nParticipants = 200
ConditionOfInterest1 = c("1Environment", "2No_Environment")
ConditionOfInterest2 = c("1Fixation", "2Pursuit")
StandardValues = c(2, 4, 6)
reps = 30
PSE_Difference_CoI1 = PSE_Environment
PSE_Difference_CoI2 = PSE_Pursuit
#for Interaction we got a value of:
PSE_Interaction
#but let's simulate power for a range of values:
Range_PSE_Interaction = PSE_Interaction*c(1,0.5, 0.15) #Performance for CoI2 is 20% lower in presence of CoI1 = NoEnvironment than in presence of CoI1 = Environment
JND_Difference_CoI1 = SD_Environment
JND_Difference_CoI2 = SD_Pursuit
JND_Interaction = SD_Interaction
Multiplicator_PSE_Standard = Mean_Standard
#estimated SDs can be inflated heavily when trial counts are low, so let's divide it by two to get a more appropriate value:
Multiplicator_SD_Standard = Multiplicator_SD_Standard
Type_ResponseFunction = Type_ResponseFunction
SD_ResponseFunction = SD_ResponseFunction
Mean_Variability_Between = Mean_Variability_Between
SD_Variability_Between = SD_Variability_Between
#Build one (large) dataset to check whether the everything was simulated properly
# set.seed(657)
# Test = SimulatePsychometricData(nParticipants = 1000,
#                          ConditionOfInterest1,
#                          ConditionOfInterest2,
#                          StandardValues,
#                          reps,
#                          PSE_Difference_CoI1,
#                          PSE_Difference_CoI2,
#                          PSE_Interaction,
#                          JND_Difference_CoI1,
#                          JND_Difference_CoI2,
#                          JND_Interaction,
#                          Multiplicator_PSE_Standard,
#                          Multiplicator_SD_Standard,
#                          Type_ResponseFunction,
#                          SD_ResponseFunction,
#                          Mean_Variability_Between,
#                          SD_Variability_Between)
#
# #Fit Psychometric Functions to the simulated data
# Test_PSEs1 = quickpsy::quickpsy(Test,Presented_TestStimulusStrength,Answer,
#                                                grouping = .(ID,StandardValues,ConditionOfInterest1,ConditionOfInterest2),
#                                                bootstrap = "none")
# Test_PSEs = Test_PSEs1$par %>% filter(parn == "p1")
# Test_PSEs$SD_Fitted = (Test_PSEs1$par %>% filter(parn == "p2"))$par
#
# save(Test_PSEs, file = paste0(dirname(rstudioapi::getSourceEditorContext()$path), "Test_PSEs.RData"))
load(file = paste0(dirname(rstudioapi::getSourceEditorContext()$path), "Test_PSEs.RData"))
Test_PSEs
###################################################################################
###############################Power Analysis######################################
###################################################################################
ConditionOfInterest1 = c("1Environment", "2No_Environment")
ConditionOfInterest2 = c("1Fixation", "2Pursuit")
StandardValues = c(2, 4, 6)
PSE_Difference_CoI1 = PSE_Environment
PSE_Difference_CoI2 = PSE_Pursuit
#for Interaction we got a value of:
PSE_Interaction
#but let's simulate power for a range of values:
Range_PSE_Interaction = PSE_Interaction*c(1,0.5, 0.15) #Performance for CoI2 is 20% lower in presence of CoI1 = NoEnvironment than in presence of CoI1 = Environment
JND_Difference_CoI1 = SD_Environment
JND_Difference_CoI2 = SD_Pursuit
JND_Interaction = SD_Interaction
Multiplicator_PSE_Standard = Mean_Standard
#estimated SDs can be inflated heavily when trial counts are low, so let's divide it by two to get a more appropriate value:
Multiplicator_SD_Standard = Multiplicator_SD_Standard
Type_ResponseFunction = Type_ResponseFunction
SD_ResponseFunction = SD_ResponseFunction
Mean_Variability_Between = Mean_Variability_Between
SD_Variability_Between = SD_Variability_Between
nIterations = 100
TimeStartSimulations = Sys.time()
PowerfulDataframe = data.frame()
for (nParticipants in c(25,50,75)){
for (reps in c(30, 50, 70)){
for (PSE_Interaction in Range_PSE_Interaction){
TimeStartTrial = Sys.time() #get time at beginning of trial
for(i in 1:nIterations){
print(paste0("Number of Participants: ", nParticipants))
print(paste0("Iteration: ", i))
print(paste0("PSE_Interaction: ", round(PSE_Interaction,4)))
#use our function to
Test = SimulatePsychometricData(nParticipants,
ConditionOfInterest1,
ConditionOfInterest2,
StandardValues,
reps,
PSE_Difference_CoI1,
PSE_Difference_CoI2,
PSE_Interaction,
JND_Difference_CoI1,
JND_Difference_CoI2,
JND_Interaction,
Multiplicator_PSE_Standard,
Multiplicator_SD_Standard,
Type_ResponseFunction,
SD_ResponseFunction,
Mean_Variability_Between,
SD_Variability_Between)
#Analysis Option 1: 1-step-approach using generalized linear mixed modelling
GLMM = glmer(Answer ~ ConditionOfInterest1*ConditionOfInterest2 + Presented_TestStimulusStrength + (Presented_TestStimulusStrength| ID) + (Presented_TestStimulusStrength| StandardValues),
family = binomial(link = "logit"),
data = Test %>% filter(Presented_TestStimulusStrength < StandardValues*3 & Presented_TestStimulusStrength > 0),
nAGQ = 1,
glmerControl(optimizer = "nloptwrap"))
#Analysis Option 2: 2-step-approach by first fitting PSEs/JNDs and then using linear mixed modelling for stats
Test_PSEs1 = quickpsy::quickpsy(Test %>% filter(Presented_TestStimulusStrength < StandardValues*3 & Presented_TestStimulusStrength > 0),Presented_TestStimulusStrength, Answer,
grouping = .(ID,StandardValues,ConditionOfInterest1,ConditionOfInterest2),
bootstrap = "none")
Test_PSEs = Test_PSEs1$par %>% filter(parn == "p1")
Test_PSEs$SD_Fitted = (Test_PSEs1$par %>% filter(parn == "p2"))$par
#Analysis Option 2a: interaction
LMM = lmer(par ~ ConditionOfInterest1*ConditionOfInterest2 + (StandardValues | ID),
data = Test_PSEs %>% filter(SD_Fitted > 0 & SD_Fitted < 3*StandardValues & par > 0 & par < 3 * StandardValues))
#Analysis Option 2b: we should see an effect when there is no environment and no effect
#when there is an environment
LMM_Split1 = lmer(par ~ ConditionOfInterest2 + (StandardValues | ID),
data = Test_PSEs %>% filter(SD_Fitted > 0 & SD_Fitted < 3*StandardValues & par > 0 & par < 3 * StandardValues) %>%
filter(ConditionOfInterest1 == "1Environment"))
LMM_Split2 = lmer(par ~ ConditionOfInterest2 + (StandardValues | ID),
data = Test_PSEs %>% filter(SD_Fitted > 0 & SD_Fitted < 3*StandardValues & par > 0 & par < 3 * StandardValues) %>%
filter(ConditionOfInterest1 == "2No_Environment"))
#save everything into
PowerfulDataframe = rbind(PowerfulDataframe,data.frame(nParticipants = rep(nParticipants,4),
rep = rep(reps,4),
PSE_Interaction = rep(PSE_Interaction,4),
WhichValue = c("PSE_GLMM","PSE_LMM","PSE_LMM_Split_Environment","PSE_LMM_Split_NoEnvironment"),
pvalue = c(summary(GLMM)$coefficients["ConditionOfInterest12No_Environment:ConditionOfInterest22Pursuit","Pr(>|z|)"],
summary(LMM)$coefficients["ConditionOfInterest12No_Environment:ConditionOfInterest22Pursuit","Pr(>|t|)"],
summary(LMM_Split1)$coefficients["ConditionOfInterest22Pursuit","Pr(>|t|)"],
summary(LMM_Split2)$coefficients["ConditionOfInterest22Pursuit","Pr(>|t|)"]),
estimate = c(summary(GLMM)$coefficients["ConditionOfInterest12No_Environment:ConditionOfInterest22Pursuit","Estimate"],
summary(LMM)$coefficients["ConditionOfInterest12No_Environment:ConditionOfInterest22Pursuit","Estimate"],
summary(LMM_Split1)$coefficients["ConditionOfInterest22Pursuit","Estimate"],
summary(LMM_Split2)$coefficients["ConditionOfInterest22Pursuit","Estimate"]),
iteration = rep(i,4)))
}
print(paste0(nIterations, " iterations took ", round(Sys.time() - TimeStartTrial), " seconds."))
print(paste0("The power for the current run through (",nParticipants," Participants, ", reps, " Repetitions) is ",mean(PowerfulDataframe$pvalue[PowerfulDataframe$nParticipants == nParticipants] < 0.05)))
save(PowerfulDataframe, file = paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/SavedVariables/PowerfulDataframe.RData"))
}
}
}
